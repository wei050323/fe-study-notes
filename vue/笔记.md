# 比较ref & reactive
## 对比
![[Pasted image 20250828155938.png]]
## 拆解todoApp中的ref使用
![[Pasted image 20250828160836.png]]
如果用不用set up 来写
```
import {ref} from 'vue';
export default{
	setup(){
		const inputText=ref("");
		``````
		return {
			inputText,
			emit,
			``````
		}
	}
}
```
# computed
```
const count = computed(()=>{
	return num.value>0?ture:false;
})
```
计算属性值会基于其响应式依赖被缓存，仅其响应式依赖更新时才会重新计算，即这里的num需要为响应式的，当num不改变，无论访问多少次count都会返回之前的计算结果。  
计算属性默认是可读的。避免直接修改计算属性值。

# watch vs watchEffect
两者都响应式地执行有副作用的回调。之间的主要区别是追踪响应式依赖的方式
- watch：只追踪明确侦听的数据源，不追踪数据源期间的其他依赖，只有数据源改变的时候才会触发回调；
- watchEffect:会在副作用发生期间追踪依赖，自动追踪所有能够访问到的响应式属性


# props，emit

1. props父传子：父组件用setup ,子组件用`defineProps`
```
//子组件
<script setup lang="ts">
defineProps<{
  title: string
  likes: number
}>()
</script>
```

2. emit子传父：
```
//子组件 
<button @click="emit">子组件向父组件进行传值</button>

js
const emit = defineEmits<{
	(e:"clear-all"):void;
}>();

//父组件
<StatusBar @clear-all="clearAllTasks"
js
const clearAllTasks=()=>{

};
```

